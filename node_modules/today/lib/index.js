'use strict';

const _ = require('lodash');
const nlp = require('compromise');
const debug = require('debug');

const { add, search, remove } = require('./mind');
const { classify } = require('./classifier');
const { sentiment } = require('./sentiment');
const { phrases } = require('./phrases');

// ./scheduler will also start a PM2 process, restarting existing process if any.
// This means that restarting `today` clears previously scheduled notifications.
//
const scheduler = require('./scheduler');
const parseTimeData = require('./parseTimeData.js');

// The API cli.js talks to
//
module.exports = {
    parse,
    scheduled: () => scheduler.then(api => api.scheduled()),
    clear: item => scheduler.then(api => api.clear(item))
};

async function parse(item, config={}) {

    if(!_.isString(item)) {
        return {
            error: `#parse called with illegal argument type: ${typeof item}: ${item}`
        }
    }

    global.STATE = Object.assign(global.STATE, config);

    item = item.trim();

    let category = classify(item);
    let doc = nlp(item);
    let data = doc.dates().data();
    let predicates = await Predicates(doc);

    let { message, targetTime, fixedTime } = parseTimeData(data);

    // Schedule the reminders for this item
    //
    await scheduler
        .then(api => api.schedule({ doc, category, targetTime, fixedTime }))
        .catch(err => {
            console.log(`Can't schedule item > ${item} > ${err}`);
        });

    // TODO Store relationships
    //

    console.log("Predicates:", predicates);
    console.log("Category:", category);


    return { message };
}

// TODO: use this for actions on inputs, like `delete last` or similar
//
function checkIfAction(doc) {
/*
    let categories = {
        'meeting': [
            `.? (meeting|meetings|meet) .? #Person .?`
        ]
    };

    return Object.keys(categories).reduce((acc, cat) => {
        categories[cat].some(m => doc.match(m).length) && acc.push(cat);
        return acc;
    }, []);
    */
}

async function Predicates(doc) {

    let item = doc.out('text');
    let nlpMethods = [
        'people',
        'organizations',
        'places',
        'phoneNumbers',
        'acronyms',
        'hashTags',
        'urls'
    ];

    let raw = nlpMethods.reduce((acc, next) => {
        console.log(doc[next]().data())
        acc[next] = doc[next]().data().map(p => _.startCase(_.toLower(p.text.trim())));
        return acc;
    }, {});

    // Check if any keywords can be considered #people, concat those that can.
    //
    raw.phrases = await phrases(item);
    raw.people = _.uniq(raw.people.concat(raw.phrases.names));
    raw.phrases = raw.phrases.keyphrases || [];

    // #list flattens all predicates
    //
    return {
        list: _.uniq(raw.phrases.concat(nlpMethods.reduce((acc, m) => acc.concat(raw[m]), []))),
        sentiment: sentiment(item),
        raw
    };
}
