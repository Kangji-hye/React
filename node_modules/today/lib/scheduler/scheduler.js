'use strict';

const Promise = require('bluebird');
const notifier = require('node-notifier');
const debug = require('debug')('today:scheduler:scheduler');
const path = require('path');

// Set by message with #type = `scheduler:config`
// #sound - the sound to play when notifying
// #notificationTimeout: Notifications expire on their own after this # of seconds
//
// @see lib/scheduler/index.js
// @see cli.js
//
let STATE = {};
let ITEM_TIMERS = {};

process.on('message', packet => {

    let data = packet.data;
    if(packet.type === 'scheduler:config') {
        STATE = Object.assign(STATE, data);
    } else if(packet.type === 'scheduler:set') {
        schedule(data);
    } else if(packet.type === 'scheduler:clear') {
        clearTimeout(ITEM_TIMERS[data.item]);
        procSend('item:cleared', data);
    } else {
        console.log(`Error: unkown message type sent to Scheduler: ${packet.type}`)
    }
});

// Broadcasts messages to process "spawner" ./index.js
//
function procSend(action, data) {
    process.send({
        type : 'process:msg',
        data : Object.assign(data, { action })
    });
}

// If #fixedTime then "zeno scheduling" -- schedule notification half distance
// to #targetTime, repeating until closed(DONE). If not, re-schedule to #targetTime
// repeatedly until DONE.
//
function schedule(data) {

    let nextNotification = data.targetTime;

    if(data.fixedTime) {
        nextNotification = parseInt(data.targetTime/2);
        data.targetTime -= nextNotification;
    }

    procSend('item:scheduled', data);

    // Set a notice to happen in the future.
    //
    ITEM_TIMERS[data.item] = setTimeout(() => notify(data)
    .then(activationType => {
        switch(activationType) {
            case 'contentsClicked': // Notification body clicked
            case 'actionClicked': // Snooze

                schedule(data);
                procSend('item:rescheduled', data);

                break;
            case 'closed': // Done button clicked
            default:

                procSend('item:closed', data);

                break;
        }
    })
    .catch(err => procSend('error', { error : err })), nextNotification);
}

function notify(data) {

    let { item, category, targetTime } = data;

    return new Promise((resolve, reject) => {

        let nc = new notifier.NotificationCenter();

        nc.notify({
            title: category,
            message: item,
            sound: false,
            closeLabel: `I'm done`,
            actions: `Snooze`,
            timeout: STATE.notificationTimeout,
            icon: path.join(__dirname, 'logo.png')
        }, (err, respType, evData) => {
            if(err) {
                debug(err);
                return reject(err);
            }

            resolve(evData.activationType);
        });
    })
}

setInterval(() => {}, 60000); // keep process running