'use strict';

const pm2 = require('pm2');
const Promise = require('bluebird');
const chalk = require('chalk');
const debug = require('debug')('today:scheduler:index');
const path = require('path');
const _ = require('lodash');

let SCHEDULED = new Set();

// Starts the PM2-managed Scheduler process that will run the file -> ./scheduler.js
// Sets up a communication bus between this process and the Scheduler process.
// Passes global STATE to Scheduler process.
// Returns API {schedule, scheduled} to lib/index.js
//
module.exports = new Promise((resolve, reject) => {

    pm2.connect(err => {
        if(err) {
            return reject(err);
        }

        pm2.start({
            name: `today-scheduler`,
            cwd: __dirname,
            script: path.join(__dirname, 'scheduler.js'),
            exec_mode: 'fork_mode',
            max_memory_restart: '500M',
            watch: true

        }, (err, apps) => {
            if(err) {
                debug(err);
                return reject(err);
            }

            let pid = apps[0].pm_id;

            pm2.launchBus((err, bus) => {
                if(err) {
                    debug(err);
                    return reject(err);
                }

                // Catch messages from the scheduler process
                //
                bus.on('process:msg', handleSchedulerMessage);

                // 1. Update config of Scheduler.
                // 2. Return API for #scheduler
                //
                pm2.sendDataToProcessId({
                    type: 'scheduler:config',
                    data: STATE,
                    id: pid,
                    topic: '*'
                }, (err, response) => {
                    if(err) {
                        debug(err);
                        return reject(err);
                    }

                    // Return the scheduler API
                    //
                    resolve({
                        schedule : Scheduler(pid),
                        scheduled : () => Array.from(SCHEDULED.values()),
                        clear: item => new Promise((resolve, reject) => {
                            pm2.sendDataToProcessId({
                                type: 'scheduler:clear',
                                data: { item },
                                topic: '*',
                                id: pid
                            }, (err, response) => {
                                if(err) {
                                    return reject(err);
                                }

                                resolve(item);
                            });
                        })
                    })
                });
            });
        });
    });
});

function Scheduler(pid) {

    return evData => Promise.try(() => {

        evData.item = evData.doc.out('text');

        if(SCHEDULED.has(evData.item)) {
            throw new Error('exists');
        }

        delete evData.doc;

        pm2.sendDataToProcessId({
            type: 'scheduler:set',
            data: evData,
            id: pid,
            topic: '*'
        }, (err, response) => {
            if(err) {
                throw err
            }

            SCHEDULED.add(evData.item);

            return response;
        });
    });
}

function handleSchedulerMessage(packet) {

    let data = packet.data;

    switch(data.action) {
        case 'item:scheduled':
            break;
        case 'item:cleared':
        case 'item:closed':
            SCHEDULED.delete(data.item);
            break;
        case 'item:rescheduled':
            break;
        case 'error':
            debug(chalk.bgBlack.red.bold(` Internal error. Exiting > ${data.error}`))
            break;
        default:
            break;
    }
}
